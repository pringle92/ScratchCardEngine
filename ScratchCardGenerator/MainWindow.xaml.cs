#region Usings

// #region Usings: Specifies the namespaces that the class depends on.
using Microsoft.Win32;
using ScratchCardGenerator.Common.Services;
using ScratchCardGenerator.ViewModels;
using System;
using System.Windows;

#endregion

namespace ScratchCardGenerator
{
    /// <summary>
    /// Represents the main window of the application. The code-behind for this View
    /// is kept minimal, as per MVVM best practices. It is responsible for initialising the window,
    /// setting up the main ViewModel, and handling window-specific lifetime and system events.
    /// </summary>
    public partial class MainWindow : Window
    {
        #region Constructor

        /// <summary>
        /// Initialises a new instance of the <see cref="MainWindow"/> class.
        /// </summary>
        public MainWindow()
        {
            // This method, generated by the XAML designer, initialises all the UI components
            // defined in the corresponding MainWindow.xaml file and wires up their events.
            InitializeComponent();

            // The DataContext for the window is set to a new instance of the MainWindowViewModel.
            // This establishes the crucial link between the View (this window) and the ViewModel,
            // enabling the powerful data binding and command features of WPF.
            DataContext = new MainWindowViewModel();

            // Subscribes to the static UserPreferenceChanged system event. This allows the application
            // to be notified whenever the user changes system-wide settings, such as the Windows theme,
            // enabling the application to adapt its appearance in real-time.
            SystemEvents.UserPreferenceChanged += UserPreferenceChanged;
        }

        #endregion

        #region Window Lifetime and Theme Events

        /// <summary>
        /// Handles the Window's Closing event, which is fired just before the window closes.
        /// This method is the central point for handling a graceful exit, such as prompting the user to save any unsaved changes.
        /// </summary>
        /// <param name="sender">The source of the event (the MainWindow).</param>
        /// <param name="e">The event arguments, which allow for cancelling the close operation.</param>
        private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            // Safely cast the DataContext to the expected ViewModel type.
            if (DataContext is MainWindowViewModel viewModel)
            {
                // Delegate the decision-making logic to the ViewModel's PromptToSaveChanges method.
                if (viewModel.PromptToSaveChanges())
                {
                    // If the user did not cancel the operation (they chose to save or not to save),
                    // the application is closing cleanly. We must clean up the auto-save file
                    // to prevent the recovery prompt on the next normal launch.
                    viewModel.CleanUpAutoSaveFile();
                }
                else
                {
                    // If PromptToSaveChanges returns false, it means the user clicked "Cancel".
                    // We must cancel the window closing event to prevent the application from exiting.
                    e.Cancel = true;
                }
            }
        }

        /// <summary>
        /// Handles the window's Closed event, which is fired after the window has been closed.
        /// This is the appropriate place to clean up resources, such as event subscriptions.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">An object that contains no event data.</param>
        private void Window_Closed(object sender, EventArgs e)
        {
            // It is critical to unsubscribe from static events when the object that subscribed is destroyed.
            // If we do not unsubscribe, the static event in the SystemEvents class will hold a reference
            // to our MainWindow instance, preventing it from being garbage collected and creating a memory leak.
            SystemEvents.UserPreferenceChanged -= UserPreferenceChanged;
        }

        /// <summary>
        /// Handles the UserPreferenceChanged system event to dynamically update the application's theme.
        /// This method is triggered when the user changes their Windows Light/Dark mode settings.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The event data, which includes the category of the preference that changed.</param>
        private void UserPreferenceChanged(object sender, UserPreferenceChangedEventArgs e)
        {
            // We are only interested in the 'General' category, which is the category that includes
            // changes to the system's application theme preference.
            if (e.Category == UserPreferenceCategory.General)
            {
                // UI updates must be performed on the application's main UI thread. The Dispatcher ensures
                // that our theme-switching logic is executed safely in this context, preventing cross-thread exceptions.
                Application.Current.Dispatcher.Invoke(() =>
                {
                    // Call the static ThemeManager to re-evaluate the system settings and apply the correct theme.
                    ThemeManager.ApplyTheme();
                });
            }
        }

        #endregion
    }
}